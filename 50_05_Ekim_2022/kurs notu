
Ä°Ã§erik:

unique_ptr
move algorithm
move_iterator
make_move_iterator
pimpl idiom

Ã¶zet:


*----------------------------------------------------------------------------------------------------- 

#include <memory>

using namespace std;

int main()
{
	unique_ptr<string> uptr;
	// ya da unique_ptr<string> uptr{nullptr};
	// ya da unique_ptr<string> uptr{new string};
	
	// new operatorÃ¼nÃ¼ aÃ§Ä±kÃ§a kullanmak istemiyorsak
	auto uptr = make_unique<string>();
	
	// eÄŸer parametreli const.'a Ã§aÄŸrÄ± yapacaksam perfect forwarding mekanizmasÄ±ndan faydalanÄ±yorum
}

*----------------------------------------------------------------------------------------------------- 

#include <memory>

using namespace std;

int main()
{
	auto uptr = make_unique<string>(100, 'A');
	// iki allocation yapar
	// 24 bytelik allocation string nesnesi iÃ§in
	// 112 bytelik allocation yazÄ±nÄ±n tutulduÄŸu bellek alanÄ± iÃ§in
}

-------------------------------------------------------- 

#include <memory>

using namespace std;

int main()
{
	auto uptr = make_unique<string>(10, 'A');  
	//tek allocation yapar
	// yazÄ±yÄ± doÄŸrudan string nesnesinin iÃ§indeki buffer'da tuttu. 
	// small string (buffer) optimization
}

*----------------------------------------------------------------------------------------------------- 

// unique_ptr sÄ±nÄ±fÄ±nÄ±n Ã¼ye fonk.'larÄ±ndan bahsettik

#include <memory>

using namespace std;

int main()
{
	unique_ptr<string> uptr{ new string};
	
	*uptr;  // iÃ§erik operator fonk. , dinamik Ã¶mÃ¼rlÃ¼ nesneye eriÅŸtiriyor
	uptr->size(); // ok operator fonk., dinamik Ã¶mÃ¼rlÃ¼ nesnenin fonk.'larÄ±nÄ± Ã§aÄŸÄ±rabiliyorsunuz
	
}  

*----------------------------------------------------------------------------------------------------- 

eÄŸer unique_ptr'niz boÅŸ ise bu durumda iÃ§erik veya ok operatorÃ¼nÃ¼ kullandÄ±ÄŸÄ±nÄ±zda 
exception throw etmez, tanÄ±msÄ±z davranÄ±ÅŸ olur. 

*----------------------------------------------------------------------------------------------------- 

// unique_ptr'nin kaynaÄŸÄ±nÄ± Ã§alabiliyorum
// move const. veya move assignment ile

#include <memory>

using namespace std;

int main()
{
	unique_ptr<string> uptr{ new string};
	
	auto x = std::move(uptr); // kaynak Ã§alma
}

*----------------------------------------------------------------------------------------------------- 

// operator bool fonk. ile boÅŸ mu dolu mu olduÄŸuna bakabilirim.
// boÅŸ olup olmadÄ±ÄŸÄ±nÄ± bilmiyorsam dereference etmem bÃ¼yÃ¼k risk
// boÅŸ olmadÄ±ÄŸÄ±nÄ± kontrol edersem sorun olmaz

#include <memory>

using namespace std;

int main()
{
	unique_ptr<string> uptr{ new string};
	
	if(uptr)
		*uptr;
	}
}

*----------------------------------------------------------------------------------------------------- 

// boÅŸ olup olmadÄ±ÄŸÄ±nÄ±z kontrol etmenin birden fazla yolu var

1) if(uptr)

2) uptr.operator bool()

3)  if(uptr != nullptr)

4) if(uptr.get())  // sarmalanan pointer'i get ediyor
if(uptr.get() != nullptr) 


*----------------------------------------------------------------------------------------------------- 

ikinci template argÃ¼manÄ± deleter

*----------------------------------------------------------------------------------------------------- 

unique_ptr sÄ±nÄ±fÄ±nÄ± bol bol tekrar edin. Ãœretimde Ã§ok kullanÄ±lÄ±yor.
En Ã¶nemli akÄ±llÄ± pointer sÄ±nÄ±fÄ±.

*----------------------------------------------------------------------------------------------------- 

// nesneyi delete etme (deleter'i Ã§aÄŸÄ±rÄ±yor)
#include <memory>

using namespace std;

int main()
{
	unique_ptr<string> uptr{ new string};
	
	uptr.reset();
	uptr.reset(nullptr);
	uptr = nullptr;
}

*----------------------------------------------------------------------------------------------------- 

// gÃ¶sterdiÄŸi nesneyi sonlandÄ±rsÄ±n ama baÅŸka bir nesnenin de mÃ¼lkiyetini alsÄ±n

#include <memory>

using namespace std;

int main()
{
	unique_ptr<string> uptr{ new string};
	
	uptr.reset(new string{"alican"});
}

*----------------------------------------------------------------------------------------------------- 

// release fonk.

#include <memory>

using namespace std;

int main()
{
	unique_ptr<string> uptr{ new string};
	
	auto ptr = uptr.release();  // mÃ¼lkiyeti bÄ±rakÄ±yor, uptr boÅŸa Ã§Ä±kar
}

*----------------------------------------------------------------------------------------------------- 

// get fonk.
mÃ¼lkiyeti bÄ±rakmaz, reset de etmez, sadece adresi dÃ¶ndÃ¼rÃ¼yor.

#include <memory>

using namespace std;

int main()
{
	unique_ptr<string> uptr{ new string};
	
	auto ptr = uptr.get();
}

*----------------------------------------------------------------------------------------------------- 

eÄŸer ikinci template argÃ¼manÄ± olarak default delete'i kullanmÄ±ÅŸsanÄ±z delete
edilecek. Ama kendi custom deleter'inizi kullanabilirsiniz. 

*----------------------------------------------------------------------------------------------------- 

#include <memory>

using namespace std;

class Nec{
public:
	Nec()
	{
		cout << "ctor\n";
	}
	
	~Nec()
	{
		ctor << "destructor\n";
	}
};

int main()
{
	cout << "main basladi\n";
	{
		const auto f = [](Nec* p){delete [] p};
		unique_ptr<int> uptr(new int[5]{});   // ciddi bir kodlama hatasÄ±
		// array delete ile delete etmek yerine normal yalÄ±n delete ile delete eder.
	}
	
	cout << "main devam ediyor\n";
}

--------------------------------------------------- 

unique_ptr<int> uptr(new int[5]{1, 2, 3, 4, 5});  // ciddi bir kodlama hatasÄ±
// array delete ile delete etmek yerine yalÄ±n delete ile delete edildi.

-------------------------------------------------- 

// eskiden ÅŸu ÅŸekilde Ã§Ã¶zÃ¼lÃ¼rdÃ¼

int main()
{
	cout << "main basladi\n";
	{
		const auto f = [](Nec* p){delete[]p};  // kendi deleterimizi kullanÄ±yoruz, array delete Ã§alÄ±ÅŸtÄ±
		unique_ptr<Nec, decltype(f)> uptr(new int[5]{});     // ok
	}
	
	cout << "main devam ediyor\n";
}

----------------------------------------------------- 

partial specialization :

template<typename T>
std::unique_ptr<T[]> {

}

farklÄ± bir interface'i olabiliyor. Bu zaten var

----------------------------------------------- 

int main()
{
	cout << "main basladi\n";
	{
		unique_ptr<Nec[]> uptr{new Nec[5]{} };     // ok
		// *uptr yok
		// uptr[] kullanÄ±labilir
		
		for(int i = 0; i < 5; ++i){
			uptr[i];
		}
	}
	
	cout << "main devam ediyor\n";
}

---------------------------------------------------------- 

// ÅŸimdiki Ã§Ã¶zÃ¼m, make_unique'in array specialization
int main()
{
	auto uptr = make_unique<Nec[]> (5);
}

*----------------------------------------------------------------------------------------------------- 

smart pointer'larÄ±n en bÃ¼yÃ¼k faydasÄ± exception safety saÄŸlamasÄ±:

#include <memory>

using namespace std;

class Nec{
public:
	Nec()
	{
		cout << "ctor\n";
	}
	
	~Nec()
	{
		ctor << "destructor\n";
	}
};

void func()
{
	auto pd = new Nec;
	
	delete pd;
}

int main()
{
	func();
}

--------------------------------------------------------------- 

void foo()
{
	throw std::runtime_error{  "hata hata\n" };
}

void func()
{
	auto pd = new Nec;
	foo();
	
	delete pd;
}

int main()
{
	try{
		func();
	}
	catch(const std::exception& ex){
		cout << "exception caught: " << ex.what() << "\n";
	}
}

// exception yakalandÄ±ÄŸÄ±nda destructor Ã§aÄŸÄ±rÄ±lmadÄ±. Bu da kaynak sÄ±zÄ±ntÄ±sÄ± demek.

*----------------------------------------------------------------------------------------------------- 

// raw pointer'Ä± smart pointer ile deÄŸiÅŸtirsem
void foo()
{
	throw std::runtime_error{  "hata hata\n" };
}

void func()
{
	auto pd = make_unique<Nec>();
	foo();
}

int main()
{
	try{
		func();
	}
	catch(const std::exception& ex){
		cout << "exception caught: " << ex.what() << "\n";
	}
}

// exception throw ederse stack unwinding yapÄ±lacak
// bÃ¼tÃ¼n otomatik Ã¶mÃ¼rlÃ¼ nesneler iÃ§in destruc. Ã§aÄŸrÄ±lacak.

*----------------------------------------------------------------------------------------------------- 

class Myclass{
public:
	~Myclass()
	{
		delete mp;
	}
public:
	Nec* mp; //
};

exception safety:
// akÄ±llÄ± pointer olsa idi hem destructor iÃ§inde delete etmem gerekmeyecekti. 
// hem exception gÃ¶nderildiÄŸinde stack unwinding ile nesne delete edilecekti
dolayÄ±sÄ±yla dinamik nesneleri kaynaklarÄ± unique_ptr ile kontrol etmek Ã§ok daha
gÃ¼venli. 

*----------------------------------------------------------------------------------------------------- 

resource leak hatasÄ± minimize edilir. 

*----------------------------------------------------------------------------------------------------- 

// Date sÄ±nÄ±fÄ±na ekleme yapÄ±yoruz
// Date'e #include <iostream>'Ä± da ekle

~Date()
{
	cout << *this << " icin destructor cagirildi";
}

int main()
{
	cout << "main basladi\n";
	
	if(1){
		auto uptr = make_unique<Date>(12, 7, 1998);
	}
	// burada uptr'nin destructor'Ä± cagrilacak
	
	cout << "main devam ediyor\n";
}

*----------------------------------------------------------------------------------------------------- 

// dinamik Ã¶mÃ¼rlÃ¼ nesneleri bir container'da tutmak istesem
// eski usul :

 int main()
{
	vector<Date*> dvec;
	
	for(int i = 0; i < = 12; ++i){
		dvec.push_back(new Date{ i , i, 2022});
	}
	
	for(auto p : dvec){
		cout << *p << "\n";
	}
}

// dikkat, hiÃ§biri delete edilmedi, Ã§Ã¼nkÃ¼ bunlar pointer
// Ã§ok Ã§ok tehlikeli 
// container nesnesi delete ediliyor, iÃ§indekiler delete edilmiyor

------------------------------------------- 

 int main()
{
	vector<Date*> dvec;
	
	for(int i = 0; i < = 12; ++i){
		dvec.push_back(new Date{ i , i, 2022});
	}
	
	for(auto p : dvec){
		cout << *p << "\n";
	}
	
	for(auto p: dvec){
		delete p;
	}
}

------------------------------------------- 

// daha da tehlikelisi 

 int main()
{
	vector<Date*> dvec;
	
	for(int i = 0; i < = 12; ++i){
		dvec.push_back(new Date{ i , i, 2022});
	}
	
	for(auto p : dvec){
		cout << *p << "\n";
	}
	
	dvec.erase(dvec.begin()); // container'den pointer'i sildim
	
	cout << "dvec.size() = " << dvec.size() << "\n";
}

 // container'den pointer'i sildim
// silinen Ã¶ÄŸe iÃ§in destructor Ã§aÄŸÄ±rÄ±lmadÄ±, Ã§ok tehlikeli

------------------------------------------- 

dolayÄ±sÄ±yla dinamik Ã¶mÃ¼rlÃ¼ nesnelerin adreslerini container'da tutabilirsiniz
ama Ã§ok problemli 

------------------------------------------- 

// ama container'da unique_ptr tutmak istesem bu problemli deÄŸil
// ama unique_ptr kopyalamaya kapatÄ±lmÄ±ÅŸ bir sÄ±nÄ±f, container'a kopyalama yoluyla 
koyamazsÄ±nÄ±z. Ã–ÄŸeyi taÅŸÄ±ma semantiÄŸi ile ekleyebilirsiniz


#include <conio.h>

using DatePtr = std::unique_ptr<Date>

int main()
{
	vector<DatePtr> vec;
	
	vec.push_back(unique_ptr<Date{new Date{1, 5, 1998}});  // veya DatePtr<Date{new Date{1, 5, 1998}}
	// push_back'in saÄŸ taraf ref. parametreli olan fonk. Ã§alÄ±ÅŸtÄ±
	
	vec.push_back(make_unique<Date> (4, 8, 2011));
	
	
	vec.emplace_back(new Date{2, 10, 1991});  
	// argÃ¼man olarak container'da tutulan Ã¶ÄŸenin const.'Ä±na gÃ¶nderilecek argÃ¼manÄ± gÃ¶ndermem
	gerekir, unique_ptr'nin const.'Ä±na ya nullptr ya dinamik bir date nesnesinin adresi
	
	for(int i = 0; i < 5; ++i){
		vec.push_back(make_unique<Date>(i, i, 2011 + i));
	}
	
	cout << "vec.size() = " << vec.size() << "\n";
	
	_getch();
}

*----------------------------------------------------------------------------------------------------- 

// emplace fonk.'larÄ± kopyalama, taÅŸÄ±ma olmadan doÄŸrudan container'in saÄŸladÄ±ÄŸÄ± bellek alanÄ±nda 
nesneyi oluÅŸturur

*----------------------------------------------------------------------------------------------------- 

bir vector'Ã¼n iÃ§inde tuttuÄŸu Ã¶ÄŸeler ne zaman destroy ediliyor ?

ya vector nesnesinin hayatÄ± bitecek, vector'Ã¼n kendi destructor'i bÃ¼tÃ¼n Ã¶ÄŸeleri destro edecek
ya biz vector'Ã¼n silme fonk. birini Ã§aÄŸÄ±racaz, silinen Ã¶ÄŸe sÄ±nÄ±f ise onun destr. Ã§aÄŸÄ±rÄ±lÄ±r, tutulan
Ã¶ÄŸeler unique_ptr tÃ¼rÃ¼nden olduÄŸundan onun destructor'i Ã§aÄŸÄ±rÄ±ldÄ±ÄŸÄ±nda o da dinamik Ã¶mÃ¼rlÃ¼ 
nesneyi delete eder. 

*----------------------------------------------------------------------------------------------------- 

#include <conio.h>

using DatePtr = std::unique_ptr<Date>
using namespace std;

int main()
{
	vector<DatePtr> vec;
	
	vec.push_back(unique_ptr<Date{new Date{1, 5, 1998}}); 
	vec.push_back(make_unique<Date> (4, 8, 2011));
	vec.emplace_back(new Date{2, 10, 1991});  
	
	for(int i = 0; i < 5; ++i){
		vec.push_back(make_unique<Date>(i, i, 2011 + i));
	}
	
	while(!vec.empty()){
		vec.pop_back();
		_getch();
	}
	
}

---------------------------------------------

container'da dinamik Ã¶mÃ¼rlÃ¼ nesnelerin adreslerini tutmak hiÃ§ iyi bir fikir deÄŸil. 
her zaman unique_ptr'nin Ã§ok daha iyi bir fikir. Ã‡Ã¼nkÃ¼ container'dan nesneyi sildiÄŸimde
onun kontrol ettiÄŸi dinamik Ã¶mÃ¼rlÃ¼ nesne de delete edilmiÅŸ olur. 
Exception safety aÃ§Ä±sÄ±ndan avantajlarÄ± var. Container'da unique_ptr tutmak avantajlÄ±. 

*----------------------------------------------------------------------------------------------------- 

using DatePtr = std::unique_ptr<Date>
using namespace std;

int main()
{
	vector<DatePtr> vec;
	vector<DatePtr> destvec(5);
	
	vec.push_back(unique_ptr<Date{new Date{1, 5, 1998}}); 
	vec.push_back(make_unique<Date> (4, 8, 2011));
	vec.emplace_back(new Date{2, 10, 1991});  
	
	for(int i = 0; i < 5; ++i){
		vec.push_back(make_unique<Date>(i, i, 2011 + i));
	}
	
	Copy(vec.begin(), vec.end(), destvec.begin());  // bir range'deki Ã¶ÄŸeleri baÅŸka bir range kopyalar
	// sentax hatasÄ±, unique_ptr kopyalamaya kapalÄ± !!!
}

----------------------------------------------- 

template <typename InIter, typename OutIter>
OutIter Copy(InIter beg, InIter end, OutIter destbeg)
{
	while(beg != end){
		*destbeg++ = *beg++;  // sentax hatasÄ±
	}
	
	return destbeg;
}

----------------------------------------------- 

template <typename InIter, typename OutIter>
OutIter Copy(InIter beg, InIter end, OutIter destbeg)
{
	while(beg != end){
		*destbeg++ = std::move(*beg++);  // ok 
	}
	
	return destbeg;
}

*----------------------------------------------------------------------------------------------------- 

bir Ã§ok programcÄ± zannediyor ki bir tane move var.
hayÄ±r iki tane move var. 

using DatePtr = std::unique_ptr<Date>
using namespace std;

int main()
{
	vector<DatePtr> vec;
	vector<DatePtr> destvec(5);
	
	vec.push_back(unique_ptr<Date{new Date{1, 5, 1998}}); 
	vec.push_back(make_unique<Date> (4, 8, 2011));
	vec.emplace_back(new Date{2, 10, 1991});  
	
	for(int i = 0; i < 5; ++i){
		vec.push_back(make_unique<Date>(i, i, 2011 + i));
	}
	
	move(vec.begin(), vec.end(), destvec.begin());  
	
	cout << "vec.size() = " << vec.size() << "\n";
	cout << "destvec.size() = " << destvec.size() << "\n";
	
	for(auto &p : vec){
		if(p)
			cout << "dolu ";
		else
			cout << "bos ";
	}
	
	cout << "\n";
	
	for(auto &p : destvec){
		if(p)
			cout << "dolu ";
		else
			cout << "bos ";
	}
	
	_getch();
	cout << "main devam ediyor\n";
}

// move'dan sonra destructor Ã§aÄŸÄ±rÄ±lmayacak Ã§Ã¼nkÃ¼ sadece taÅŸÄ±ndÄ±
// destvec'in Ã¶mrÃ¼ bittiÄŸinde destructor Ã§aÄŸrÄ±lacak

*----------------------------------------------------------------------------------------------------- 

std::move algoritmasÄ± var !!!

*----------------------------------------------------------------------------------------------------- 

#include <algorithm>
#include <iterator>

using DatePtr = std::unique_ptr<Date>
using namespace std;

int main()
{
	vector<DatePtr> vec;
	
	vec.push_back(unique_ptr<Date{new Date{1, 5, 1998}}); 
	vec.push_back(make_unique<Date> (4, 8, 2011));
	vec.emplace_back(new Date{2, 10, 1991});
	
	
	auto x = *vec.begin(); // sentax hatasÄ±, Ã§Ã¼nkÃ¼ kopyalamaya kapatÄ±lmÄ±ÅŸtÄ±r
}

----------------------------------------------------- 

#include <algorithm>
#include <iterator>

using DatePtr = std::unique_ptr<Date>
using namespace std;

int main()
{
	vector<DatePtr> vec;
	
	vec.push_back(unique_ptr<Date{new Date{1, 5, 1998}}); 
	vec.push_back(make_unique<Date> (4, 8, 2011));
	vec.emplace_back(new Date{2, 10, 1991});
	
	
	auto x = std::move(*vec.begin());  // ok !!!
}

----------------------------------------------------- 

baÅŸka bir yolu : move_iterator

#include <algorithm>
#include <iterator>

using DatePtr = std::unique_ptr<Date>
using namespace std;

int main()
{
	vector<DatePtr> vec;
	
	vec.push_back(unique_ptr<Date{new Date{1, 5, 1998}}); 
	vec.push_back(make_unique<Date> (4, 8, 2011));
	vec.emplace_back(new Date{2, 10, 1991});
	
	move_iterator<vector<DatePtr>::iterator>  miter{ vec.begin() };
	
	auto x = *miter;  // ok
}

----------------------------------------------------- 

daha kolay yazma yolu :  make_move_iterator

#include <algorithm>
#include <iterator>

using DatePtr = std::unique_ptr<Date>
using namespace std;

int main()
{
	vector<DatePtr> vec;
	
	vec.push_back(unique_ptr<Date{new Date{1, 5, 1998}}); 
	vec.push_back(make_unique<Date> (4, 8, 2011));
	vec.emplace_back(new Date{2, 10, 1991});
	
	
	cout << (vec[0] ? "dolu" : "bos") << "\n";
	auto x = *make_move_iterator(vec.begin());
	
	cout << *x << "\n";
	
	cout << (vec[0] ? "dolu" : "bos") << "\n";
	_getch();
}

----------------------------------------------------- 

	move_iterator<vector<DatePtr>::iterator> 
	// move_iterator bir iteratÃ¶r adaptÃ¶rÃ¼. TÃ¼r argÃ¼manÄ± olarak normal bir iteratÃ¶r verdiÄŸinizde
	// dereference ettiÄŸinizde onu saÄŸ taraf deÄŸeri yapÄ±yor

*----------------------------------------------------------------------------------------------------- 

*iter : lvalue

auto uptr = *iter;  // hata, Ã§Ã¼nkÃ¼ unique_ptr kopyalamaya kapalÄ±

auto uptr = *miter; // rvalue, taÅŸÄ±ma semantiÄŸi devreye girer

*----------------------------------------------------------------------------------------------------- 

gÃ¶rdÃ¼klerimiz :

move_iterator<iter_type>

make_move_iterator(iter)

*----------------------------------------------------------------------------------------------------- 

class Myclass{

private: 
	//
	std::unique_ptr<std::string> mptr;
};

int main()
{
	Myclass m1;
	Myclass m2{m1}; // hata
	m2 = m1;  // hata
}

soru 1: Myclass sÄ±nÄ±fÄ±nÄ±n default const.'Ä± var mÄ± ?
tabiki var.

soru 2: Myclass sÄ±nÄ±fÄ±nÄ±n copy const.'Ä± deleted mi ?
deleted.

copy assignment'i deleted mi ?
deleted.

neden deleted ? *this mptr'sini copy const. edecek diÄŸerinin mptr'si ile
copy const. delete edilmiÅŸ olduÄŸu iÃ§in sentax hatasÄ± vermek yerine copy
const.'Ä±nÄ± delete eder. 

------------------------------------------------ 

class Myclass{

private: 
	//
	std::unique_ptr<std::string> mptr;
};

int main()
{
	Myclass m1;
	Myclass m2(std::move(m1));  // ok
	
	m1 = std::move(m2);  // ok
}

*----------------------------------------------------------------------------------------------------- 

bir sÄ±nÄ±fÄ±n unique_ptr elemanÄ± varsa ve siz herhangi birÅŸekilde fonk.
yazmadÄ±ysanÄ±z move only type haline geliyor. 
Zaten doÄŸal olan bu. 

*----------------------------------------------------------------------------------------------------- 

class Myclass{
public:
	Myclass(const Myclass& other) : mptr(other.mptr) {}  // sentax hatasÄ± verir. Ama
	derleyici yazarsa hata vermemek iÃ§in delete eder. 
private: 
	//
	std::unique_ptr<std::string> mptr;
};

----------------------------------------- 

class Myclass{
public:
	Myclass(const Myclass& other) = delete;
private: 
	//
	std::unique_ptr<std::string> mptr;
};

*----------------------------------------------------------------------------------------------------- 

soru : ben Myclass nesnelerinin kopyalanabilir olmasÄ±nÄ± istiyorsam ?
deep copy yapacaz !!!

class Myclass{
	Myclass(const Myclass& other) : mptr{ other.mptr ? new std::string(*other.mptr) : nullptr}
	// veya mptr{new std::make_unique<std::string>(*other.mptr) }
	// other'in mptr'si boÅŸ olmamalÄ±
	
	Myclass& operator = (const Myclass& other)
	{
		mptr.reset(other.mptr ? new std::string(*other.mptr) : nullptr);
	}
	
private: 
	//
	std::unique_ptr<std::string> mptr;
};

int main()
{
	Myclass m1;
	
	Myclass m2 = m1; // hata
}

*----------------------------------------------------------------------------------------------------- 

class Myclass;

int main()
{
	std::unique_ptr<Myclass> uptr;
}

sentax hatasÄ± neden ?
incomplete type mi 

------------------------------------------------ 

class Myclass;

Myclass* foo();

int main()
{
	Myclass* p = foo();  
	
	delete p;  // hata, incomplete type'i delete ettiÄŸimde destructor'Ä± Ã§aÄŸÄ±rÄ±lÄ±r
	// Myclass delete edilebilmesi iÃ§in complete type olmasÄ± gerekiyor. 
	
}

*----------------------------------------------------------------------------------------------------- 

#include <memory>

class Nec;

class Myclass{

private:
	std::unique_ptr<Nec> mp;
};


#include "myclass.h"

int main()
{
	Myclass m;  // sentax hatasÄ± !!!
}

neden sentax hatasÄ± oldu ?
Ã§ok kolay deÄŸil sorunun cevabÄ±. SÄ±nÄ±fÄ±n default const. default init eder, problem yok.
Destructor non-static, public, inline fonksiyonu.
mp'nin destructor'Ä±nÄ± Ã§aÄŸÄ±rÄ±r. mp'nin destructor'Ä± Nec'in destructor'Ä±nÄ± Ã§aÄŸÄ±rÄ±r. 
Nec incomplete type olduÄŸu iÃ§in sentax hatasÄ± oldu.
Yani kodu sÄ±nÄ±fÄ±n iÃ§inde, bÃ¼tÃ¼n problem bu inline olmasÄ±

class Nec;

class Myclass{
public:
	~Myclass()
	{
		// mp'nin destructor'Ä±nÄ± Ã§aÄŸÄ±rÄ±r.
		// mp.~
	}
private:
	std::unique_ptr<Nec> mp;
};


#include "myclass.h"

int main()
{
	Myclass m;  // sentax hatasÄ± !!!
}

-------------------------------------------------- 

bu kodu legal hale getirmenin yolu var mÄ± ? 

class Myclass{
public:
	~Myclass();
	
private:
	std::unique_ptr<Nec> mp;
};


#include "myclass.h"

class Nec{  // complete type

};

Myclass::~Myclass() = default; 
//bu bildirimi gÃ¶rÃ¼nce default edecek
// artÄ±k complete type olduÄŸu iÃ§in bir problem olmayacak


void func()
{
	Myclass m;  // ok !!!
}

--------------------------------------------------------- 

bu Ã¶zellik nerede iÅŸime yarayacak ?

#include "myclass.h"

class Erg;

int main()
{
	Erg* p;
	
	delete p;  // sentax hatasÄ±, delete ettiÄŸim yerde erg sÄ±nÄ±fÄ± complete type olsa
	// problem olmayacaktÄ±.
}

*----------------------------------------------------------------------------------------------------- 

pimpl idiom : (pointer implementation'Ä±n kÄ±saltÄ±lmasÄ±)

Ã¼retimde en fazla kullanÄ±lan tekniklerden biri

diÄŸer isimleri : handle-body idiom
cheshire cat 
opaque pointer

bu idiom ile bir sÄ±nÄ±fÄ±n private bÃ¶lÃ¼mÃ¼nÃ¼ client kodlardan gizliyoruz. 

--------------------------------------------- 

#include <string>
#include "date.h"
#include <vector>

class Student{
public:

private:
	std::string m_name;
	Date m_bdate;
	std::vector<int> m_grades;
	// ...
}

------------------------------------------- 

ama eÄŸer bu sÄ±nÄ±fÄ±n private bÃ¶lÃ¼mÃ¼nÃ¼ bir ÅŸekilde gizleyebilirsem 
baÅŸlÄ±k dosyalarÄ±nÄ± da include etmem gerekmez.

Bir sÄ±nÄ±fÄ±n private veri elemanlarÄ±nÄ± neden gizlemek isteyelim ki ?
Ã§Ã¼nkÃ¼ bunlar sÄ±nÄ±f tanÄ±mÄ± iÃ§inde olursa h dosyalarÄ±nÄ± include etmek
zorunda kalacaÄŸÄ±m.

OlasÄ± dezavantajlar:
1) hangi veri elemanlarÄ±nÄ±n kullandÄ±ÄŸÄ±nÄ±zÄ± herkese deklere etmiÅŸ oluyorsunuz
(en Ã¶nemsizi, bilmesi Ã§ok da Ã¶nemli deÄŸil)
2) bu h. filelarÄ±n include ettiÄŸi h. file'larÄ±n da client kodlar tarafÄ±ndan
include edilmesi demek.
40 tane 50 tane baÅŸlÄ±k dosyasÄ±nÄ± eklemiÅŸ olur. Bunlar bildirim kod size'i etkilemiyor
ama compile time daha uzun sÃ¼recek. 
3) en Ã¶nemli problem baÄŸÄ±mlÄ±lÄ±k.
Bu baÅŸlÄ±k dosyalarÄ±nda bir deÄŸiÅŸiklik olursa o baÅŸlÄ±k dosyasÄ±nÄ± include eden bÃ¼tÃ¼n 
kodlarÄ±n yeniden derlenmesi gerekecek. Bu yapÄ±lmazsa abstract interface farkÄ± olacak
bu da tanÄ±msÄ±z davranÄ±ÅŸ demek

------------------------------------------------------- 
 
#include <string>
#include "date.h"
#include <vector>

class Student{
public:
	void print()const;
private:
	std::string m_name;
	Date m_bdate;
	std::vector<int> m_grades;
	// ...
};

---------- 

// student.cpp
#include "student.h"
#include <iostream>

void Student::print()const
{
	std::cout << m_name << "\n";
	std::cout << m_bdate << "\n";
	
	for(const auto i : m_grades)
		std::cout << i << " ";
		
	std::cout << "\n";
}

---------------------------------------------- 

pimple idiom'u ne yapÄ±yor ?
// baÅŸlÄ±k dosyalarÄ±na gerek yok 

// Student.h
class Student{
public:
	Student();
	~Student();
	void print()const;
	void set();
	int get_best_grade()const;
private:
	struct pimpl;
	pimpl* mp;

};

// Student.cpp  // bunun client'lar ile alakasÄ± yok
#include "student.h"
#include <string>
#include "date.h"
#include <vector>
#include <algorithm>

struct Student:pimpl{
	std::string m_name;
	Date m_bdate;
	std::vector<int> m_grades;
	
	void print()const
	{
		std::cout << mp->m_name <<  "\n";
		std::cout << mp->m_bdate <<  "\n";
		for(const auto i : mp->m_grades)
			std::cout << i << " ";
		std::cout << "\n";
	}
};

Student::Student() : mp{new pimpl} {

}

void Student::print()const
{
	mp->print();  // daha Ã¶nce doÄŸrudan eriÅŸtiÄŸim yerde pointer ile eriÅŸim
}

Student::~Student()
{
	delete mp;
}

int Student::get_best_grade()const
{
	return *std::max_element(mp->m_grades.begin(), mp->m_grades.end());
}

// main.cpp
#include "student.h"

int main()
{
	Student s;
	
	s.print();
	s.set();
	auto grade = s.get_best_grade();
}

*----------------------------------------------------------------------------------------------------- 

dezavantajlarÄ± : 
her Student nesnesi iÃ§in dinamik Ã¶mÃ¼rlÃ¼ bir pimple nesnesi oluÅŸturulacak,
bunun iÃ§in allocation yapÄ±lacak ve bunun bir maliyeti var.

bÃ¼yÃ¼k projelerde bÃ¼tÃ¼n baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± kaldÄ±rmasÄ± aÃ§Ä±sÄ±ndan
tercih edilir. 

daha Ã¶nce doÄŸrudan eriÅŸtiÄŸim yerde pointer ile eriÅŸim
pimple pointer'in gÃ¶sterdiÄŸi nesnenin elemanlarÄ±na eriÅŸecem, maliyeti var

*----------------------------------------------------------------------------------------------------- 

pimpl'i geleneksel yÃ¶ntemlerle yapÄ±ldÄ± ama
ya destructor Ã§aÄŸÄ±rÄ±lmadan bir exception throw ederse resource
leak olur. 

pimpl idiomunu unique_ptr ile implemente edin.  Bunu yapabilmeniz iÃ§in
sizin sÄ±nÄ±fÄ±nÄ±zÄ±n elemanÄ±nÄ±n unique_ptr'nin bir incomplete type olmasÄ± gerekiyor. 
Bu durumda sÄ±nÄ±fÄ±n destruc.'Ä±nÄ± derleyicinin yazmasÄ±nÄ± saÄŸlarsanÄ±z, derleyicinin
yazdÄ±ÄŸÄ± inline fonk.  incomplete type tÃ¼rÃ¼nden bir nesneyi delete ettiÄŸi iÃ§in
problem olur. 

-----------------------------

unique_ptr ile implementasyon :

// Student.h
#include <memory>
class Student{
public:
	Student();
	~Student();
	void print()const;
	void set();
	int get_best_grade()const;
private:
	struct pimpl;
	std::unique_ptr<pimpl> mp;
};


// Student.cpp  // bunun client'lar ile alakasÄ± yok
#include "student.h"
#include <string>
#include "date.h"
#include <vector>
#include <algorithm>

struct Student:pimpl{
	std::string m_name;
	Date m_bdate;
	std::vector<int> m_grades;
	
	void print()const
	{
		std::cout << mp->m_name <<  "\n";
		std::cout << mp->m_bdate <<  "\n";
		for(const auto i : mp->m_grades)
			std::cout << i << " ";
		std::cout << "\n";
	}
};

Student::Student() : mp{ std::make_unique<pimpl>()} { // new pimpl

}

Student::~Student() = default;

void Student::print()const
{
	mp->print();  // daha Ã¶nce doÄŸrudan eriÅŸtiÄŸim yerde pointer ile eriÅŸim
}

int Student::get_best_grade()const
{
	return *std::max_element(mp->m_grades.begin(), mp->m_grades.end());
}

// main.cpp
#include "student.h"

int main()
{
	Student s;
	
	s.print();
	s.set();
	auto grade = s.get_best_grade();
}

destructor'in kodu gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ noktada student'in pimple'i complete type haline
gelir. 

*----------------------------------------------------------------------------------------------------- 

eÄŸer pimpl idiomunu unique_ptr ile init ediyorsanÄ±z, mutlaka
unique_ptr<pimple> aÃ§Ä±lÄ±mÄ± incomplete type aÃ§Ä±lÄ±m olduÄŸu iÃ§in,
derleyicinin yazdÄ±ÄŸÄ± fonk. inline olursa incomplete type'i delete etmiÅŸ olur.

Ã¶nce unique_ptr'nin incomplete type aÃ§Ä±lÄ±mÄ± kullanÄ±labilir, ama 
unique_ptr'nin destructor'i Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda sarmaladÄ±ÄŸÄ± pointer'i delete
ettiÄŸinde incomplete type'i delete etmiÅŸ oluyor. Sentax hatasÄ±. Delete
edildiÄŸi noktada complete type olmasÄ± gerekir.
 
*----------------------------------------------------------------------------------------------------- 

fast pimple idiom : ileri C++
neden hÄ±zlÄ± ? Ã§Ã¼nkÃ¼ dinamik allocation yapmÄ±yor

*-----------------------------------------------------------------------------------------------------

unique_ptr array partial specialization
unique_ptr ve exception handling
						unique_ptr hatalarÄ±
					
pimple idiom
	pointer implementation
	unique_ptr implementation

elemanÄ± unique_ptr olan sÄ±nÄ±flar
unique_ptr for incomplete types

anlatÄ±ldÄ±ğŸ™‚

factory functions
sink functions
pass through

*----------------------------------------------------------------------------------------------------- 

